#' @title Predict method for dfunc objects
#' 
#' @description Predict likelihood parameters for distance function objects
#' 
#' @param object An estimated dfunc object.  See \code{dfuncEstim}. 
#' 
#' @param newdata A data frame containing new values of 
#' the covariates at which predictions are to be computed. 
#' 
#' @param type The type of predictions desired. Currently, only 
#' type = "parameters" is implemented, which returns 
#' predicted parameters of the likelihood function.  
#' 
#' 
#' @param \dots Included for compatibility with generic \code{predict} methods.
#' 
#' @return A matrix of predicted parameters of the likelihood used to estimate
#' the distance function
#' in \code{dfunc}. The extent of the first dimension (rows) in 
#' the returned matrix is equal to either the number of detection distances 
#' in \code{detectionData} or number of rows in \code{newdata}. 
#' The returned matrix's second dimension (columns) is 
#' the number of canonical parameters in the likelihood 
#' plus the number of expansion terms.  Without expansion terms, the number 
#' of columns in the returned matrix 
#' is either 1 or 2 depending on the likelihood (e.g., \code{halfnorm} has 
#' one parameter, \code{hazrate} has two). See the help 
#' for each likelihoods to interpret the returned parameter values.
#' 
#' @seealso \code{\link{halfnorm.like}}, \code{\link{negexp.like}}, 
#' \code{\link{uniform.like}}, \code{\link{hazrate.like}}, \code{\link{Gamma.like}}
#' 
#' @export
#' 
#' @importFrom stats terms as.formula delete.response model.frame model.matrix coef
#' 

# Extra Roxygen comments when we get around implmenting other types of
# predictions 
# Type = "inflation" predicts the inflation factor for all
# observations.  Inflation factors use likelihood parameters to compute
# effective sampling distances (ESW or EDR) and inverts them.
# type = "function" predicts the actual distance functions


 
predict.dfunc <- function(object, newdata, 
          type = c("parameters"), ...) 
{
  if (!inherits(object, "dfunc")) 
    stop("object is not a dfunc")
  
  hasCovars <- !is.null(object$covars)
  
  if (missing(newdata) || is.null(newdata)) {
    n <- length(object$dist)
  } else {
    n <- nrow(newdata)
  }
  
  if(hasCovars){
    # X is the covariate matrix for predictions 
    if (missing(newdata) || is.null(newdata)) {
      X <- object$covars
    } else {
      # (jdc, 6/25/2018) bug fix suggested by Diem
      # formula is stored, don't try and extract from call (which fails if formula is generated by paste)
      # Terms <- terms(as.formula(object$call[["formula"]]))
      # (tlm, 9/15/2022) model frame is stored in object. Safest formula to use 
      # is there
      # Terms <- terms(as.formula(object$formula))  # Jason's bug fix
      Terms <- terms(object$model.frame)
      Terms <- delete.response(Terms)
      m <- model.frame(Terms, newdata)
      X <- model.matrix(Terms, m, contrasts.arg = attr(object$covars,"contrasts"))
    }
    
    BETA <- coef(object)
    beta <- BETA[1:ncol(X)]   # could be extra parameters tacked on. e.g., knee for uniform
    params <- X %*% beta
    params <- exp(params)  # All link functions are exp...thus far
    if(ncol(X)<length(BETA)){
      extraParams <- matrix(BETA[(ncol(X)+1):length(BETA)], n, length(BETA)-ncol(X), byrow=TRUE)
      params <- cbind(params, extraParams)
    }
  } else {
    params <- coef(object) 
    params <- matrix(params, nrow=n, ncol=length(params), byrow=TRUE)
  }  

  # Implement different types of predictions here. 
  # type <- match.arg(type)
  # if(type == "inflation"){
  #   params <- effectiveDistance()
  # }

  params
}