# Write a function that does all the testing in these sections. 
# i.e., write a function that fits a distance funciton, then 
# tests coef, ESW, AIC, print, and plot against input values.
#

# Need to test:  presence of covariates, Point surveys

cat(crayon::bgYellow("Installed test_dfuncEstim function\n"))

test_dfuncEstim <- function( params, 
                             detectDf = sparrowDetectionData, 
                             formula = dist ~ 1){
  
  for( i in 1:nrow(params) ){
    testParams <- paste0("i=", i, "/", nrow(params),
                         ", Like=", params$likelihood[i], 
                         ", w.lo=", params$w.lo[i],
                         ", w.hi=", params$w.hi[i], 
                         ", pointSurvey=", params$pointSurvey[i],
                         ", expansions=", params$expansions[i], 
                         ", x.scl=", params$x.scl[i], 
                         ", g.x.scl=", params$g.x.scl[i], 
                         ", observer=", params$observer[i],
                         ", outputUnits=", params$outputUnits[i]
    )
    
    
    context(testParams)
    
    # cat(crayon::green(paste("i=",i,testParams)))
    # cat("\n")
    
    if( params$x.scl[i] == "max" ){
      param.x.scl = "max"
    } else {
      param.x.scl = units::set_units(as.numeric(params$x.scl[i]), "m")
    }
    param.w.lo  = units::set_units(as.numeric(params$w.lo[i]), "m")

    if( !is.character(param.x.scl) ){
      if( param.x.scl < param.w.lo ){
        test_that("x.scl less than w.lo warning", {
          expect_warning(
            dfuncEstim(formula = formula,
                       detectionData=detectDf,
                       likelihood = params$likelihood[i],  
                       w.lo = param.w.lo,
                       w.hi = units::set_units(params$w.hi[i], "m"), 
                       pointSurvey = params$pointSurvey[i], 
                       expansions = params$expansions[i], 
                       x.scl = param.x.scl, 
                       g.x.scl = as.numeric(params$g.x.scl[i]), 
                       observer = params$observer[i], 
                       outputUnits = params$outputUnits[i]), 
            regexp = "x.scl is less than specified lower limit"
          )
        })
        param.x.scl <- param.w.lo
      }
    }
    
    # First, check for warnings generated by fit
    tmp <- tryCatch(dfuncEstim(formula = formula,
                        detectionData=detectDf,
                        likelihood = params$likelihood[i],  
                        w.lo = param.w.lo,
                        w.hi = units::set_units(params$w.hi[i], "m"), 
                        pointSurvey = params$pointSurvey[i], 
                        expansions = params$expansions[i], 
                        x.scl = param.x.scl, 
                        g.x.scl = as.numeric(params$g.x.scl[i]), 
                        observer = params$observer[i], 
                        outputUnits = params$outputUnits[i]), error = function(e){e}, warning = function(w){w})
    
    if( inherits(tmp, "warning") | inherits(tmp, "error") ){
      # I cannot seem to trap the warning thrown by dfuncEstim AND return the 
      # fitted object outside test_that. So, it's totally redundant, but I do 
      # the same tests here as in the false clause of this "if". 
      
      test_that("Under singular var-cov warning", {
        dfuncFit <- expect_warning( dfuncEstim(formula = formula,
                             detectionData=detectDf,
                             likelihood = params$likelihood[i],
                             w.lo = param.w.lo,
                             w.hi = units::set_units(params$w.hi[i], "m"),
                             pointSurvey = params$pointSurvey[i],
                             expansions = params$expansions[i],
                             x.scl = param.x.scl,
                             g.x.scl = as.numeric(params$g.x.scl[i]),
                             observer = params$observer[i],
                             outputUnits = params$outputUnits[i]),
                     regexp = "Singular variance-covariance matrix")
        
        test_that("Like", {
          expect_output(print(dfuncFit), regexp = paste0("\\nFunction: ", toupper(params$likelihood[i]), "\\s+\\n"))
        })
        
        convergeMess <- "FAILURE .singular variance-covariance matrix."
        test_that(convergeMess, {
          expect_output(print(dfuncFit), regexp = paste0("\\nConvergence: ", convergeMess, "\\n"))
        })
        
        test_that("Strip", {
          lo <- units::set_units( units::set_units(params$w.lo[i], "m"), params$outputUnits[i], mode = "standard" )
          hi <- units::set_units( units::set_units(params$w.hi[i], "m"), params$outputUnits[i], mode = "standard" )
          tstString <- paste0("Strip: ", format(lo), " to ", format(hi))
          tstString <- gsub("[\\[\\]]", ".", tstString, perl = T)
          expect_output(print(dfuncFit), regexp = tstString)
        })

        test_that("ESW computation", {
          expect_length(ESW(dfuncFit), 1)
        })
        
        test_that("ESW print", {
          esw <- format(ESW(dfuncFit))
          esw <- gsub("[\\[\\]]", ".", esw, perl = T)
          if(params$pointSurvey[i]){
            tstString <- paste("Effective detection radius \\(EDR\\):", esw)
          } else {
            tstString <- paste("Effective strip width \\(ESW\\):", esw)
          }
          expect_output(print(dfuncFit), regexp = tstString)
        })
        
        test_that("Scaling", {
          if( !is.character(param.x.scl) ){
            x0 <- format(units::set_units( param.x.scl,  params$outputUnits[i], mode = "standard" ))
          } else {
            x0 <- format(dfuncFit$x.scl)
          }
          x0 <- gsub("[\\[\\]]", ".", x0, perl = T)
          tstString <- paste0("Scaling: g\\(", x0, "\\) = ", params$g.x.scl[i])
          expect_output(print(dfuncFit), regexp = tstString)
        })
        
        test_that("AICc computation", {
          expect_length(AIC(dfuncFit), 1)
        })    
        
        test_that("AICc", {
          expect_output(print(dfuncFit), regexp = "\\nAICc: [0-9\\.]+\\n")
        })
      })
    } else {
      if( any(is.na(diag(tmp$varcovar))) | any(diag(tmp$varcovar) < 0.0) ){
        convergeMess <- "FAILURE .singular variance-covariance matrix."
      } else {
        convergeMess <- "Success"
      }

      dfuncFit <- dfuncEstim(formula = formula,
                           detectionData=detectDf,
                           likelihood = params$likelihood[i],  
                           w.lo = param.w.lo,
                           w.hi = units::set_units(params$w.hi[i], "m"), 
                           pointSurvey = params$pointSurvey[i], 
                           expansions = params$expansions[i], 
                           x.scl = param.x.scl, 
                           g.x.scl = as.numeric(params$g.x.scl[i]), 
                           observer = params$observer[i], 
                           outputUnits = params$outputUnits[i])
      
      test_that(convergeMess, {
        expect_output(print(dfuncFit), regexp = paste0("\\nConvergence: ", convergeMess, "\\n"))
      })
  
      # Basically, go down the output line by line testing. If it prints, it's good.
      test_that("Like", {
        expect_output(print(dfuncFit), regexp = paste0("\\nFunction: ", toupper(params$likelihood[i]), "\\s+\\n"))
      })
  
      test_that("Strip", {
        lo <- units::set_units( units::set_units(params$w.lo[i], "m"), params$outputUnits[i], mode = "standard" )
        hi <- units::set_units( units::set_units(params$w.hi[i], "m"), params$outputUnits[i], mode = "standard" )
        tstString <- paste0("Strip: ", format(lo), " to ", format(hi))
        tstString <- gsub("[\\[\\]]", ".", tstString, perl = T)
        expect_output(print(dfuncFit), regexp = tstString)
      })
  
      test_that("ESW computation", {
        expect_length(ESW(dfuncFit), 1)
      })
      
      test_that("ESW print", {
        esw <- format(ESW(dfuncFit))
        esw <- gsub("[\\[\\]]", ".", esw, perl = T)
        if(params$pointSurvey[i]){
          tstString <- paste("Effective detection radius \\(EDR\\):", esw)
        } else {
          tstString <- paste("Effective strip width \\(ESW\\):", esw)
        }
        expect_output(print(dfuncFit), regexp = tstString)
      })
      
      test_that("Scaling", {
        if( !is.character(param.x.scl) ){
          x0 <- format(units::set_units( param.x.scl,  params$outputUnits[i], mode = "standard" ))
        } else {
          x0 <- format(dfuncFit$x.scl)
        }
        x0 <- gsub("[\\[\\]]", ".", x0, perl = T)
        tstString <- paste0("Scaling: g\\(", x0, "\\) = ", params$g.x.scl[i])
        expect_output(print(dfuncFit), regexp = tstString)
      })
      
      test_that("AICc computation", {
        expect_length(AIC(dfuncFit), 1)
      })    
          
      test_that("AICc", {
        expect_output(print(dfuncFit), regexp = "\\nAICc: [0-9\\.]+\\n")
      })
    }
  }

}  
  
  