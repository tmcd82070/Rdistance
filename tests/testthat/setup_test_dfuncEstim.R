#' @title test_dfuncEstim - A function to test distance functions
#' 
#' @description A function that accepts a set of distance 
#' function parameters, estimates distance functions from them, and 
#' applies specific tests. 
#' 
#' @param dfuncParams A data frame containing parameters to 
#' \code{dfuncEstim}.  Tests are applied to distance function 
#' objects estimated from the parameter of each row of this data frame. 
#' See documentation for \code{dfuncEstim} for the list of parameters 
#' that can be used.  Names of the variables in this data frame just match
#' parameters in the function \code{dfuncEstim}.
#' 
#' @param abundParams A data frame containing parameters to 
#' \code{abundEstim}.  
#' See documentation for \code{abundEstim} for the list of parameters 
#' that can be used.  
#' 
#' @param abundDf A data frame containing abundance data (like 
#' transect length) to use 
#' for estimating abundance. Parameters are 'area', 'ci', 'R', 
#' 'plot.bs', 'showProgress' and 'bySite'. If NULL, do not 
#' estimate abundance, only estimate (and test) distance function.
#' 
#' @param detectDf A data frame containing distance data to use 
#' for estimating distance functions. 
#' 
#' @param formula A formula object giving the distance function 
#' to be estimated from each row of parameters.
#' 
#' @return NULL.  This function is run for it's testing side effects. 
#' 
#' @examples 
#' 
#' p <- data.frame(likelihood = c("halfnorm", "hazrate"), 
#'                 w.lo = c(0, 100))
#' test_dfuncEstim( p )               


# Notes: Need to test:  presence of covariates, Point surveys

cat(crayon::bgYellow("Installed test_dfuncEstim function\n"))

test_dfuncEstim <- function( detectParams,
                             abundParams = NULL,
                             detectDf = sparrowDetectionData, 
                             abundDf = sparrowSiteData,
                             formula = dist ~ 1){
  
  for( i in 1:nrow(detectParams) ){
    testParams <- paste0("D:", i, "/", nrow(detectParams),
                         ", Like=", detectParams$likelihood[i], 
                         ", w.lo=", detectParams$w.lo[i],
                         ", w.hi=", detectParams$w.hi[i], 
                         ", pointSurvey=", detectParams$pointSurvey[i],
                         ", expansions=", detectParams$expansions[i], 
                         ", x.scl=", detectParams$x.scl[i], 
                         ", g.x.scl=", detectParams$g.x.scl[i], 
                         ", observer=", detectParams$observer[i],
                         ", outputUnits=", detectParams$outputUnits[i]
    )
    
    
    context(testParams)
    
    # cat(crayon::green(paste("i=",i,testParams)))
    # cat("\n")
    
    # ---- x.scl param ----
    if( detectParams$x.scl[i] == "max" ){
      param.x.scl = "max"
    } else {
      param.x.scl = units::set_units(as.numeric(detectParams$x.scl[i]), 
                                     detectParams$outputUnits[i], 
                                     mode = "standard")
    }
    
    # ---- w.lo param ----
    param.w.lo = units::set_units(as.numeric(detectParams$w.lo[i]),
                                  detectParams$outputUnits[i], 
                                  mode = "standard")
    
    # ---- w.hi param ----
    if( is.na(detectParams$w.hi[i]) ){
      param.w.hi <- NULL
    } else {
      param.w.hi = units::set_units(detectParams$w.hi[i], 
                                  detectParams$outputUnits[i], 
                                  mode = "standard")
    }
    
    # ---- param.x.scl < param.w.lo Warning ----
    if( !is.character(param.x.scl) ){
      if( param.x.scl < param.w.lo ){
        # could run this case in separate "warnings" test file
        test_that("x.scl less than w.lo warning", {
          expect_warning(
            dfuncEstim(formula = formula,
                       detectionData=detectDf,
                       likelihood = detectParams$likelihood[i],  
                       w.lo = param.w.lo,
                       w.hi = param.w.hi, 
                       pointSurvey = detectParams$pointSurvey[i], 
                       expansions = detectParams$expansions[i], 
                       x.scl = param.x.scl, 
                       g.x.scl = as.numeric(detectParams$g.x.scl[i]), 
                       observer = detectParams$observer[i], 
                       outputUnits = detectParams$outputUnits[i]), 
            regexp = "x.scl is less than specified lower limit"
          )
        })
        param.x.scl <- param.w.lo
      }
    }
    
    # ---- Error/Warning trapped ----
    # First, check for warnings generated by fit
    tmp <- tryCatch(dfuncEstim(formula = formula,
                        detectionData=detectDf,
                        likelihood = detectParams$likelihood[i],  
                        w.lo = param.w.lo,
                        w.hi = param.w.hi, 
                        pointSurvey = detectParams$pointSurvey[i], 
                        expansions = detectParams$expansions[i], 
                        x.scl = param.x.scl, 
                        g.x.scl = as.numeric(detectParams$g.x.scl[i]), 
                        observer = detectParams$observer[i], 
                        outputUnits = detectParams$outputUnits[i]), error = function(e){e}, warning = function(w){w})
    
    if( inherits(tmp, "warning") | inherits(tmp, "error") ){
      # I cannot seem to trap the warning thrown by dfuncEstim AND return the 
      # fitted object outside test_that. So, when an error or warning is thrown, 
      # refit under "expect warning" which returns the fitted object. 
      # This is inefficient because same fit happens twice in this case.
      dfuncFit <- expect_warning( dfuncEstim(formula = formula,
                             detectionData=detectDf,
                             likelihood = detectParams$likelihood[i],
                             w.lo = param.w.lo,
                             w.hi = param.w.hi,
                             pointSurvey = detectParams$pointSurvey[i],
                             expansions = detectParams$expansions[i],
                             x.scl = param.x.scl,
                             g.x.scl = as.numeric(detectParams$g.x.scl[i]),
                             observer = detectParams$observer[i],
                             outputUnits = detectParams$outputUnits[i]))
                     #regexp = "Singular variance-covariance matrix")
    } else {
      # no warning first time
      dfuncFit <- tmp
    }

    
    # ---- Tests ----
    # Now that we have the fitted object, go down the output 
    # line by line testing. If it prints, it's good.
    
    if( is.na(detectParams$w.hi[i]) ){
      param.w.hi <- dfuncFit$w.hi
    }
    
    if( dfuncFit$convergence == 0 ) {
      vcDiag <- diag(dfuncFit$varcovar)
      if( any(is.na(vcDiag)) | any(vcDiag < 0.0)) {
        convergemess <- "(singular variance-covariance matrix)"
      } else {
        convergemess <- "Success"
      }
    } else {
      convergemess <- dfuncFit$fit$message
    }
    
    test_that("Convergence message prints", {
      expect_output(print(dfuncFit), regexp = convergemess)
    })
  
    test_that("Like prints", {
      expect_output(print(dfuncFit), regexp = paste0("\\nFunction: ", toupper(detectParams$likelihood[i]), "\\s+\\n"))
    })

    test_that("Strip", {
      tstString <- paste0("Strip: ", format(param.w.lo), " to ", format(param.w.hi))
      tstString <- gsub("[\\[\\]]", ".", tstString, perl = T)
      expect_output(print(dfuncFit), regexp = tstString)
    })

    # test effectiveDistance runs first, then re-run and store it
    # Would be better to assign returned effectiveDistance to correct 
    # frame, but these run fast so okay to re-run
    test_that("Effective distance computes", {
      expect_length(effectiveDistance(dfuncFit), 1)
    })
    
    efd <- effectiveDistance(dfuncFit)
    
    test_that("Effective distance >= 0", {
      zero <- units::set_units(0, dfuncFit$outputUnits, mode = "standard")
      expect_gte(efd, zero)
    })

    nominalW <- param.w.hi - param.w.lo
    if( (inherits(param.x.scl, "units") && param.x.scl == param.w.lo) || is.character(param.x.scl) ){
      # if param.x.scl != param.w.lo & param.x.scl != "max", we 
      # don't know the range of effective distance because g(x) could be > 1 for some x.
      # Don't test in this case.  Warnings and red text are printed and plotted.
      test_that("Effective distance <= w.hi-w.lo", {
        expect_lte(efd, nominalW)
      })
    }
    
    test_that("Effective distance prints", {
      efdString <- format(efd)
      efdString <- gsub("[\\[\\]]", ".", efdString, perl = T)
      if(detectParams$pointSurvey[i]){
        tstString <- paste("Effective detection radius \\(EDR\\):", efdString)
      } else {
        tstString <- paste("Effective strip width \\(ESW\\):", efdString)
      }
      expect_output(print(dfuncFit), regexp = tstString)
    })
    
    if( efd > nominalW ){
      # check that red text is printed
      tstString <- "> \\(w.hi - w.lo\\)"
      expect_output(print(dfuncFit), regexp = tstString)
    }
    
    test_that("Scaling prints", {
      if( !is.character(param.x.scl) ){
        x0 <- format(param.x.scl)
      } else {
        x0 <- format(dfuncFit$x.scl)
      }
      x0 <- gsub("[\\[\\]]", ".", x0, perl = T)
      tstString <- paste0("Scaling: g\\(", x0, "\\) = ", detectParams$g.x.scl[i])
      expect_output(print(dfuncFit), regexp = tstString)
    })
    
    # Same deal as effectiveDistance: test first, then rerun to compute
    test_that("AICc computes", {
      expect_length(AIC(dfuncFit), 1)
    })
    aic <- AIC(dfuncFit)
        
    test_that("AICc prints", {
      expect_output(print(dfuncFit), regexp = paste0("\\nAICc: ", format(aic), "\\n"))
    })

    test_that("BIC prints", {
      bic <- AIC(dfuncFit, criterion = "BIC")
      expect_output(print(dfuncFit, criterion = "BIC"), regexp = paste0("\\nBIC: ", format(bic), "\\n"))
    })
    
    # ---- Test abundance methods for these parameters ----
    if(!is.null(abundParams)){
      test_abundEstim(abundParams = abundParams, 
                 dfuncDf = detectDf, 
                 abundDf = abundDf,
                 distFunc = dfuncFit)
    }
      
  }

}  
  
  