% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/predict.dfunc.R
\name{predict.dfunc}
\alias{predict.dfunc}
\title{predict.dfunc - Predict distance functions}
\usage{
\method{predict}{dfunc}(x, newdata = NULL, type = c("parameters"), distances = NULL, ...)
}
\arguments{
\item{x}{An estimated detection function object, normally 
produced by calling \code{\link{dfuncEstim}}.}

\item{newdata}{A data frame containing new values of 
the covariates at which to evaluate the distance functions. 
If \code{newdata}
is NULL, distance functions are evaluated at values of 
the observed covariates and results in one prediction 
per distance or transect (see parameter \code{type}). 
If \code{newdata} is not NULL and the model does not contains covariates, 
this routine returns one prediction for each row in \code{newdata}, but 
columns and values in \code{newdata} are ignored.}

\item{type}{The type of predictions desired. 
\itemize{
  \item \bold{If \code{type} == "parameters"}: Returned values are
    predicted (canonical) parameters of the likelihood function. 
    If \code{newdata} is NULL, return contains one parameter
    value for every detection in \code{x} with a distance.
    If \code{newdata} is not NULL, returned vector has one parameter
    for every row in \code{newdata}.
  \item \bold{If \code{type} == "dfuncs"}: Returned  
    value is a matrix of scaled distance functions, 
    with distance functions in columns. Distance functions 
    are evaluated at distances   
    in argument \code{distances}, not at the observed 
    distances in \code{x}. The number of distance functions
    returned (i.e., number of columns) depends on \code{newdata}: 
    \itemize{
       \item If \code{newdata} is NULL, one distance function 
       will be returned for every detection in \code{x}
       that has valid covariate values. 
      \item If \code{newdata} is not NULL, one distance function 
      will be returned for each observation (row) in \code{newdata}. 
    }
   \item \bold{If \code{type} == "density"}: Returned object is a data frame
   containing one row per transect and estimated values for density on each 
   transect. 
   \item \bold{If \code{type} == "abundance"}: Returned object is a data frame
   containing one row per transect and estimated values for abundance on each 
   transect. Abundance estimates are density estimates multiplied by the surveyed 
   area of each transect (i.e., length times nominal width = length * 2(w.hi - w.lo)).
 }
 
 If \code{x} is a smoothed distance function, it does not have parameters
 and this routine will always return a scaled distance function. That is, 
 \code{type} = "parameters" when \code{x} is smoothed 
 does not make sense and the smoothed distance function estimate will be returned
 if \code{type} does not equal "density" or "abundance".}

\item{distances}{A vector of distances at which to evaluate 
distance functions, when distance functions 
are requested.  \code{distances} must have measurement units. 
Any distances outside the observation 
strip (\code{x$w.lo} to \code{x$w.hi}) are discarded.  If 
\code{distances} is NULL, this routine uses a sequence of 201 evenly 
spaced distances between 
\code{x$w.lo} and \code{x$w.hi}, inclusive.}

\item{\dots}{Included for compatibility with generic \code{predict} methods.}
}
\value{
A matrix containing one of two types of predictions: 
\itemize{
  \item \bold{If \code{type} is "parameters"}, the returned matrix 
  contains predicted likelihood parameters. The extent of the 
  first dimension (rows) in 
  the returned matrix is equal to either the number of detection distances 
  in \code{x} 
  or number of rows in \code{newdata}. 
  The returned matrix's second dimension (columns) is 
  the number of parameters in the likelihood 
  plus the number of expansion terms.  Without expansion terms, the number 
  of columns in the returned matrix 
  is either 1 or 2 depending on the likelihood (e.g., \code{halfnorm} has 
  one parameter, \code{hazrate} has two). See the help 
  for each likelihoods to interpret the returned parameter values.
  
  \item \bold{If \code{type} is "dfuncs"}, columns of the 
  returned matrix contain scaled distance functions (i.e., \emph{g(x)}).  
  The extent of the first 
  dimension (number of rows) is either the number of distances 
  specified in \code{distances}
  or \code{options()$Rdistance_intEvalPts} if \code{distances} is not specified.
  The extent of the second dimension (number of columns) is: 
    \itemize{
      \item the number of detections with distances: if \code{newdata} is NULL.
      \item the number of rows in \code{newdata} if 
       \code{newdata} is specified.
    }
  All distance functions in columns of the return are scaled 
  to \code{x$g.x.scale} at \code{x$x.scl}. The returned matrix has 
  the following additional attributes:
   \itemize{
      \item \code{attr(return, "distances")} is the vector of distances used to 
      predict the function in \code{return}.  Either the input \code{distances} object
      or the computed sequence of distances when \code{distances} is NULL. 
      \item \code{attr(return, "x0")} is the vector of distances at which each 
       distance function in \code{return} was scaled. i.e., the vector of 
       \code{x.scl}.
      \item \code{attr(return, "g.x.scl")} is the height of \emph{g(x)} (the distance 
       function) at \emph{x0}. 
  }
  
  \item \bold{If \code{type} is "density"}...
  
  \item \bold{If \code{type} is "abundance"}...
}
}
\description{
Predict either likelihood parameters, 
distance functions, site-specific density, or 
site-specific abundance from estimated distance function 
objects.
}
\examples{

data(sparrowDetectionData)
data(sparrowSiteData)
sparrowDf <- RdistDf(sparrowSiteData, sparrowDetectionData)

# For dimension checks:
nd <- getOption("Rdistance_intEvalPts")
n  <- nrow(dfuncObs$mf)

# No covariates
dfuncObs <- sparrowDf |> dfuncEstim(formula = dist ~ 1
                     , w.hi = units::as_units(100, "m"))
                     
p <- predict(dfuncObs) # parameters
all(dim(p) == c(nd, 1)) 

# values in newdata ignored because no covariates
p <- predict(dfuncObs, newdata = data.frame(x = 1:5))
all(dim(p) == c(5, 1)) 

# Distance functions in columns, one per observation
p <- predict(dfuncObs, type = "dfunc") 
all(dim(p) == c(nd, n))

d <- units::set_units(c(0, 20, 40), "ft")
p <- predict(dfuncObs, distances = d, type = "dfunc") 
all(dim(p) == c(3, n))

p <- predict(dfuncObs
   , newdata = data.frame(x = 1:5)
   , distances = d
   , type = "dfunc") 
all(dim(p) == c(3, 5))

# Covariates
dfuncObs <- sparrowDf |> dfuncEstim(formula = dist ~ observer
                     , w.hi = units::as_units(100, "m"))
predict(dfuncObs)  # n X 1

Observers <- data.frame(observer = levels(sparrowSiteData$observer))
predict(dfuncObs, newdata = Observers) # 5 X 1

predict(dfuncObs, type = "dfunc") # nd X n
predict(dfuncObs, newdata = Observers, type = "dfunc") # nd X 5
predict(dfuncObs
  , newdata = Observers
  , distances = d
  , type = "dfunc") # 3 X 5

}
\seealso{
\code{\link{halfnorm.like}}, \code{\link{negexp.like}}, 
\code{\link{uniform.like}}, \code{\link{hazrate.like}}, \code{\link{Gamma.like}}
}
